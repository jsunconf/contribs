var Types                        = require('../constants/types');
//var Charsets                     = require('../constants/charsets');
//var Field                        = require('./Field');

module.exports = BinaryRowDataPacket;
function BinaryRowDataPacket() {
}

BinaryRowDataPacket.prototype.parse = function(parser, fieldPackets, typeCast, nestTables, connection) {
  var nullBitmapLength = Math.floor((fieldPackets.length + 7 + 2) / 8);
  var nullBitmap = parser.parseBuffer(nullBitmapLength);

  // packet header (0x00)
  parser.parseUnsignedNumber(1);

  for (var i = 0; i < fieldPackets.length; i++) {
    var fieldPacket = fieldPackets[i];

    // *sigh*
    var isNull = !!(nullBitmap[Math.floor((i + 2) / 8)] & 1<<((i + 2) % 8));
    var value = (isNull)
      ? value = null
      : value = decode(parser, fieldPacket);

    // @TODO: remove duplication with RowDataPacket
    if (typeof nestTables == "string" && nestTables.length) {
      this[fieldPacket.table + nestTables + fieldPacket.name] = value;
    } else if (nestTables) {
      this[fieldPacket.table] = this[fieldPacket.table] || {};
      this[fieldPacket.table][fieldPacket.name] = value;
    } else {
      this[fieldPacket.name] = value;
    }
  }
};

function decode(parser, field) {
  console.log(field.flags);

  var value;
  switch (field.type) {
    case Types.LONG:
      value = parser.parseUnsignedNumber(4);
      break;
    case Types.VAR_STRING:
      return parser.parseLengthCodedString();
    default:
      return new Error('BinaryRowDataPacket: type not implemented: ' + field.type);
  }

  console.log(value);
  //value = value.toString(2);
}
